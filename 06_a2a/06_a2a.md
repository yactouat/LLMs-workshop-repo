# Step 6: Agent-to-Agent (A2A) Protocol

## Goal
Learn about the A2A (Agent-to-Agent) protocol, an open standard that enables agent interoperability across different frameworks and vendors. This step demonstrates the A2A protocol concepts (Agent Cards, JSON-RPC 2.0 communication) using simplified in-process agents. While this demo uses basic Python classes for simplicity, the A2A protocol is designed to enable agents built with different technologies (LangGraph, CrewAI, custom frameworks) to discover each other's capabilities and collaborate through standardized communication.

## Prerequisites
Before starting this step, ensure you have:
- Completed previous steps (understanding of agents and multi-agent patterns)
- Python virtual environment activated
- Required dependencies installed (`pip install -r requirements.txt`)
- Ollama running with models pulled OR Google API configured

**Note**: Unlike Steps 2-5, this demo does NOT require the knowledge base (`acme.db`). It demonstrates A2A protocol concepts using simplified in-process agents. The demo shows the protocol structure (Agent Cards, JSON-RPC messages) but uses basic Python classes rather than actual different frameworks. In production, A2A enables real cross-framework interoperability (e.g., LangGraph agent â†” CrewAI agent).

## What You'll Learn
- What the **A2A protocol** is and why it matters
- How **Agent Cards** enable capability discovery
- How **JSON-RPC 2.0** provides standardized communication
- The difference between **A2A** (agent-to-agent) and **MCP** (agent-to-tool)
- How A2A enables **cross-framework agent ecosystems** (conceptually; this demo uses simplified agents)
- When to use A2A vs. other multi-agent patterns

## A2A Protocol Overview

### What is A2A?

The **Agent-to-Agent (A2A) Protocol** is an open standard from the Linux Foundation that enables AI agents from different frameworks, vendors, and platforms to discover and communicate with each other.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Agent-to-Agent (A2A) Protocol                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LangGraph  â”‚                              â”‚   CrewAI    â”‚
â”‚    Agent    â”‚                              â”‚    Agent    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                            â”‚
       â”‚  1. Discover via Agent Card                â”‚
       â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
       â”‚                                            â”‚
       â”‚  2. A2A Task Request (JSON-RPC 2.0)        â”‚
       â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
       â”‚                                            â”‚
       â”‚  3. A2A Response (JSON-RPC 2.0)            â”‚
       â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       â”‚                                            â”‚

Different frameworks, same protocol!
```

### Key Features

1. **Standardized Communication**: JSON-RPC 2.0 over HTTP/HTTPS
2. **Capability Discovery**: Agent Cards describe what agents can do
3. **Framework Agnostic**: Works with any framework (LangGraph, CrewAI, custom agents)
4. **Industry Support**: Backed by Linux Foundation, Google, and 50+ partners
5. **Transport Flexible**: HTTP, WebSocket, gRPC support

### A2A vs MCP

Both are open standards for AI systems, but serve different purposes:

| Feature | **MCP** (Model Context Protocol) | **A2A** (Agent-to-Agent) |
|---------|----------------------------------|--------------------------|
| **Purpose** | Agent-to-Tool communication | Agent-to-Agent communication |
| **Connects** | Agents â†’ Tools/Resources | Agents â†’ Other Agents |
| **Use Case** | Access databases, APIs, files | Delegate tasks between agents |
| **Example** | Agent uses MCP to query database | Orchestrator uses A2A to delegate to specialist |
| **Scope** | Tool/resource integration | Agent collaboration |

**Complementary Relationship:**
- **MCP**: An agent uses MCP to access a vector database (tool)
- **A2A**: That agent then uses A2A to share its findings with another agent

## The Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              A2A PROTOCOL DEMONSTRATION                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

STEP 1: Agent Creation
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Research Agent   â”‚              â”‚ Orchestrator     â”‚
â”‚ (Server/Worker)  â”‚              â”‚ Agent (Client)   â”‚
â”‚                  â”‚              â”‚                  â”‚
â”‚ â€¢ answer_questionâ”‚              â”‚ â€¢ Discovers      â”‚
â”‚ â€¢ research_topic â”‚              â”‚   agents         â”‚
â”‚ â€¢ summarize      â”‚              â”‚ â€¢ Delegates      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚   tasks          â”‚
                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

STEP 2: Capability Discovery (Agent Cards)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Agent Card     â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚ agentId: "..."   â”‚
â”‚ name: "..."      â”‚
â”‚ capabilities: [] â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Orchestrator discovers
â”‚ endpoint: "..."  â”‚          what agent can do
â”‚ protocol: {...}  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

STEP 3: Task Delegation (JSON-RPC 2.0)
Orchestrator                     Research Agent
    â”‚                                  â”‚
    â”‚  POST /a2a/research-agent-001   â”‚
    â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚
    â”‚  {                               â”‚
    â”‚    "jsonrpc": "2.0",             â”‚
    â”‚    "method": "answer_question",  â”‚
    â”‚    "params": {...}               â”‚
    â”‚  }                               â”‚
    â”‚                                  â”‚
    â”‚           â—€Processingâ–¶           â”‚
    â”‚                                  â”‚
    â”‚  â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
    â”‚  {                               â”‚
    â”‚    "jsonrpc": "2.0",             â”‚
    â”‚    "result": {...}               â”‚
    â”‚  }                               â”‚
    â”‚                                  â”‚

STEP 4: Result Processing
Orchestrator receives and processes the result
```

## Core Concepts

### 1. Agent Cards

**Agent Cards** are JSON documents that advertise an agent's capabilities. They're like business cards for AI agents.

```json
{
  "agentId": "research-agent-001",
  "name": "ACME Research Agent",
  "description": "Provides research and information lookup capabilities",
  "capabilities": [
    "research_topic",
    "answer_question",
    "summarize_information"
  ],
  "protocol": {
    "version": "1.0",
    "transport": "http",
    "format": "json-rpc-2.0"
  },
  "endpoint": "http://localhost:8000/a2a/research-agent-001",
  "authentication": {
    "type": "none"
  }
}
```

**Key Fields:**
- `agentId`: Unique identifier for the agent
- `name`: Human-readable name
- `description`: What the agent does
- `capabilities`: List of methods the agent provides
- `endpoint`: Where to send A2A requests
- `protocol`: Communication protocol details

**Key Function**: `create_agent_card()` in a2a_demo.py:45

### 2. JSON-RPC 2.0 Format

A2A uses **JSON-RPC 2.0** for all requests and responses.

**Request Format:**
```json
{
  "jsonrpc": "2.0",
  "id": "task-001",
  "method": "answer_question",
  "params": {
    "requestingAgent": "orchestrator-001",
    "question": "What are AI agents?"
  }
}
```

**Response Format (Success):**
```json
{
  "jsonrpc": "2.0",
  "id": "task-001",
  "result": {
    "question": "What are AI agents?",
    "answer": "AI agents are autonomous software..."
  }
}
```

**Response Format (Error):**
```json
{
  "jsonrpc": "2.0",
  "id": "task-001",
  "error": {
    "code": -32000,
    "message": "Capability not supported"
  }
}
```

**Key Functions**:
- `create_a2a_task_request()` in a2a_demo.py:89
- `create_a2a_response()` in a2a_demo.py:123

### 3. Capability Discovery

Before delegating tasks, agents must discover what other agents can do.

**Discovery Flow:**
```python
# Step 1: Server publishes Agent Card
agent_card = research_agent.get_agent_card()

# Step 2: Client discovers the agent
orchestrator.discover_agent(agent_card)

# Step 3: Client knows capabilities
# capabilities = ["research_topic", "answer_question", "summarize_information"]

# Step 4: Client can delegate appropriate tasks
task = orchestrator.delegate_task(
    target_agent_id="research-agent-001",
    capability="answer_question",
    parameters={"question": "..."}
)
```

### 4. Task Delegation

Once discovered, the orchestrator can delegate tasks to specialized agents.

**Delegation Flow:**
1. **Create request** with capability and parameters
2. **Send to agent endpoint** (HTTP POST in real implementations)
3. **Agent processes** the request
4. **Agent returns result** in JSON-RPC 2.0 format
5. **Orchestrator uses result** in its workflow

## The Agents

### Research Agent (Server/Worker)

**Role**: Provides research capabilities via A2A protocol

**Capabilities:**
- `research_topic`: Provides research summaries on topics
- `answer_question`: Answers questions using LLM
- `summarize_information`: Summarizes provided text

**Implementation:**
```python
class ResearchAgent:
    def __init__(self, llm, agent_id: str = "research-agent-001"):
        self.llm = llm
        self.agent_card = create_agent_card(
            agent_id=agent_id,
            name="ACME Research Agent",
            capabilities=["research_topic", "answer_question", "summarize_information"]
        )

    def get_agent_card(self) -> Dict[str, Any]:
        """Publish capabilities for discovery"""
        return self.agent_card

    def process_task(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """Process A2A task requests"""
        # Validate capability
        # Execute appropriate method
        # Return JSON-RPC response
```

**Key Function**: `ResearchAgent` class in a2a_demo.py:159

### Orchestrator Agent (Client)

**Role**: Discovers agents and delegates tasks

**Responsibilities:**
- Discover available agents via Agent Cards
- Track discovered agents and their capabilities
- Delegate tasks to appropriate agents
- Handle responses from worker agents

**Implementation:**
```python
class OrchestratorAgent:
    def __init__(self, agent_id: str = "orchestrator-001"):
        self.discovered_agents = {}  # agent_id -> agent_card

    def discover_agent(self, agent_card: Dict[str, Any]) -> None:
        """Add agent to discovery registry"""
        self.discovered_agents[agent_card["agentId"]] = agent_card

    def delegate_task(self, target_agent_id: str, capability: str, parameters: Dict) -> Dict:
        """Create A2A task request for delegation"""
        return create_a2a_task_request(...)
```

**Key Function**: `OrchestratorAgent` class in a2a_demo.py:246

## Running the Demo

### Provider Support

This script supports both **local Ollama models** and **cloud models via Google AI Studio**.

**To use Ollama (default):**
```bash
# Ensure Ollama is running with models
ollama pull llama3.1
# or
ollama pull qwen3
```

**To use Google AI Studio:**
1. Create a `.env` file in repository root:
   ```
   LLM_PROVIDER=google
   GOOGLE_API_KEY=your_api_key_here
   GOOGLE_MODEL=gemini-3-flash-preview
   ```
2. Run the demo (automatically uses Google models)

### Basic Mode

```bash
python3 06_a2a/a2a_demo.py
```

This will:
1. Create Research and Orchestrator agents
2. Demonstrate Agent Card exchange
3. Show two A2A task delegations:
   - `answer_question` capability
   - `research_topic` capability
4. Display all JSON-RPC messages
5. Show results from the Research Agent

### Thinking Model Mode

See the LLM's reasoning process:

```bash
python3 06_a2a/a2a_demo.py --thinking
```

**With Ollama:**
- Uses `qwen3` or model specified by `OLLAMA_THINKING_MODEL`

**With Google:**
- Uses model specified by `GOOGLE_THINKING_MODEL`

## Expected Output

### Step 1: Agent Creation
```
STEP 1: Creating A2A-Compliant Agents
----------------------------------------------------------------------
âœ“ Created Research Agent: research-agent-001
âœ“ Created Orchestrator Agent: orchestrator-001
```

### Step 2: Agent Discovery
```
STEP 2: Agent Discovery (Agent Card Exchange)
----------------------------------------------------------------------
The Research Agent publishes its Agent Card:

{
  "agentId": "research-agent-001",
  "name": "ACME Research Agent",
  "description": "Provides research and information lookup capabilities",
  "capabilities": [
    "research_topic",
    "answer_question",
    "summarize_information"
  ],
  ...
}

The Orchestrator discovers the Research Agent:
âœ“ Discovered agent: ACME Research Agent (research-agent-001)
  Capabilities: research_topic, answer_question, summarize_information
  Endpoint: http://localhost:8000/a2a/research-agent-001
```

### Step 3: Task Delegation
```
STEP 3: Task Delegation via A2A Protocol
----------------------------------------------------------------------
Orchestrator delegates task to Research Agent:
  Capability: answer_question
  Question: What are the benefits of using AI agents in enterprise applications?

A2A Request (JSON-RPC 2.0 format):
{
  "jsonrpc": "2.0",
  "id": "demo-task-001",
  "method": "answer_question",
  "params": {
    "requestingAgent": "orchestrator-001",
    "question": "What are the benefits of using AI agents..."
  }
}

Research Agent processing request...

A2A Response (JSON-RPC 2.0 format):
{
  "jsonrpc": "2.0",
  "id": "demo-task-001",
  "result": {
    "question": "What are the benefits of using AI agents...",
    "answer": "[LLM's answer about AI agent benefits]"
  }
}

----------------------------------------------------------------------
Answer from Research Agent:
----------------------------------------------------------------------
[Detailed answer about AI agent benefits in enterprises]
```

### Step 4: Another A2A Interaction
```
STEP 4: Another A2A Interaction - Topic Research
----------------------------------------------------------------------
Orchestrator requests topic research:
  Capability: research_topic
  Topic: Multi-agent systems and their applications

Research Agent processing request...

----------------------------------------------------------------------
Research Summary on 'Multi-agent systems and their applications':
----------------------------------------------------------------------
[LLM's research summary about multi-agent systems]
```

## Demo vs. Production Implementation

### This Demo (Simplified)
- **In-process agents**: Agents in same Python process (both are simple Python classes)
- **Direct function calls**: No actual HTTP requests
- **Same framework**: Both agents use basic Python (not demonstrating cross-framework yet)
- **No authentication**: Simplified for learning
- **Single machine**: Everything runs locally
- **Purpose**: Demonstrates A2A protocol concepts (Agent Cards, JSON-RPC format) rather than actual cross-framework interoperability

### Production A2A (Real World)
- **Cross-framework agents**: Agents built with different technologies (LangGraph, CrewAI, custom)
- **Distributed agents**: Agents on different servers/services
- **HTTP/HTTPS transport**: Real network communication
- **Authentication**: OAuth, API keys, JWT tokens
- **Service discovery**: Agent registries, DNS, service mesh
- **Error handling**: Retries, timeouts, circuit breakers
- **Monitoring**: Logging, tracing, metrics

## Real-World A2A Implementations

### 1. python-a2a Library
Python implementation of the A2A protocol:
```python
from a2a import Agent, AgentCard, A2AServer

# Create A2A-compliant agent
agent = Agent(
    agent_id="my-agent",
    capabilities=["task1", "task2"]
)

# Run as HTTP server
server = A2AServer(agent)
server.run(port=8000)
```

**Repository**: github.com/themanojdesai/python-a2a

### 2. LangGraph A2A Support
LangGraph provides native A2A integration:
```python
# Deploy LangGraph agent with A2A endpoint
from langgraph.server import create_a2a_server

server = create_a2a_server(
    graph=my_graph,
    agent_id="langgraph-agent"
)
# Automatically creates /a2a/{assistant_id} endpoint
```

**Documentation**: docs.langchain.com/langsmith/server-a2a

### 3. Google Agent Development Kit (ADK)
Google's A2A-based agent framework:
```python
from google_adk import Agent

@Agent.capability("answer_question")
def handle_question(question: str) -> str:
    # Implementation
    pass
```

## When to Use A2A

### âœ… Use A2A When:

1. **Multi-Vendor Agent Ecosystems**
   - Agents from different vendors need to collaborate
   - Example: LangGraph agent delegates to CrewAI agent

2. **Agent Marketplaces**
   - Building platform where agents can discover and hire each other
   - Example: Specialized agents offer services to orchestrators

3. **Enterprise Integration**
   - Integrating AI capabilities across departments/systems
   - Example: HR agent needs to query Finance agent

4. **Service-Oriented Architecture**
   - AI agents as microservices
   - Example: Research service, Writing service, Analysis service

5. **Cross-Framework Collaboration**
   - Teams using different frameworks need interoperability
   - Example: Python LangGraph agent works with Node.js agent

### âŒ Don't Use A2A When:

1. **Single Framework System**
   - All agents in same codebase using same framework
   - **Use patterns from Steps 3-5 instead** (simpler, faster)

2. **Agent-to-Tool Communication**
   - Agent needs to access databases, APIs, files
   - **Use MCP instead** (designed for tool access)

3. **Simple Task**
   - Single agent can handle it
   - **Use ReAct pattern** (Step 3)

4. **Performance Critical**
   - HTTP overhead not acceptable
   - **Use in-process multi-agent** (Steps 4-5)

## Comparing All Workshop Patterns

| Pattern | Communication | Use Case | Best For |
|---------|--------------|----------|----------|
| **Step 1: Basic LLM** | None | Direct Q&A | Simple queries |
| **Step 2: RAG** | Linear chain | Knowledge retrieval | Augmented responses |
| **Step 3: ReAct** | Agent â†” Tools | Tool-based tasks | Single agent with tools |
| **Step 4: Supervisor** | Hierarchical (same framework) | Multi-agent coordination | Fixed workflows, single framework |
| **Step 5: Network** | Peer-to-peer (same framework) | Adaptive collaboration | Flexible workflows, single framework |
| **Step 6: A2A** | Standardized protocol (cross-framework) | Agent interoperability | Multi-vendor, distributed systems |

## Code Structure

```
06_a2a/
â”œâ”€â”€ 06_a2a.md          # This documentation
â””â”€â”€ a2a_demo.py        # A2A protocol demonstration
```

## Key Takeaways

1. **A2A enables cross-framework agent collaboration** using open standards
2. **Agent Cards provide capability discovery** so agents know what others can do
3. **JSON-RPC 2.0 ensures standardized communication** across all implementations
4. **A2A complements MCP**: MCP for tools, A2A for agents
5. **Industry-backed standard**: Linux Foundation, Google, 50+ partners
6. **Production-ready**: python-a2a, LangGraph A2A, Google ADK available
7. **Different from previous patterns**: Enables multi-vendor ecosystems, not just in-process agents

## Comparison: Steps 4, 5, and 6

### Supervisor Pattern (Step 4)
```
[Same framework, in-process]
Supervisor â†’ Worker 1 â†’ Supervisor â†’ Worker 2 â†’ Final Answer
```
- **Control**: Centralized
- **Framework**: Single (LangGraph)
- **Protocol**: Internal (Python function calls)

### Network Pattern (Step 5)
```
[Same framework, in-process]
Agent A â†” Agent B â†” Agent C â†’ Final Answer
```
- **Control**: Distributed
- **Framework**: Single (LangGraph)
- **Protocol**: Internal (Python function calls)

### A2A Pattern (Step 6)
```
[Cross-framework, distributed]
LangGraph Agent â†’ [HTTP A2A] â†’ CrewAI Agent â†’ Final Answer
```
- **Control**: Service-based
- **Framework**: Any (cross-framework)
- **Protocol**: Standardized (HTTP + JSON-RPC 2.0)

## Advanced Topics

### A2A + Supervisor Pattern

Combine A2A with supervisor pattern for powerful architectures:

```python
# Supervisor can delegate to both local and remote agents
class A2ASupervisor:
    def __init__(self):
        self.local_agents = [...]      # Steps 4-5 agents
        self.remote_agents = [...]     # A2A agents

    def route(self, task):
        # Decide: local or remote agent?
        if task_needs_remote_capability:
            # Use A2A
            response = requests.post(
                remote_agent.endpoint,
                json=create_a2a_request(...)
            )
        else:
            # Use local agent
            response = local_agent.run(task)
```

### A2A + Network Pattern

Network agents can include A2A agents as peers:

```python
# Network of mixed local and remote agents
def researcher_handoff_decision():
    if need_specialized_capability:
        # Handoff to remote A2A agent
        return handoff_to_a2a_agent(
            capability="specialized_analysis"
        )
    else:
        # Handoff to local network agent
        return handoff_to_writer()
```

### Agent Registries

In production, use agent registries for discovery:

```python
# Register agent with directory service
registry.register(agent_card)

# Discover agents by capability
agents = registry.find_by_capability("answer_question")

# Select best agent
best_agent = select_by_cost_and_latency(agents)
```

## Troubleshooting

**Issue**: "Agent not discovered"
- **Solution**: Verify Agent Card format matches A2A spec
- Check that `agentId` is unique

**Issue**: "Capability not supported"
- **Solution**: Verify capability name in Agent Card matches request
- Check that agent implements the capability method

**Issue**: LLM not responding
- **Solution**:
  - For Ollama: Ensure Ollama is running and model pulled
  - For Google: Verify API key in `.env` file

**Issue**: JSON-RPC format errors
- **Solution**: Ensure `jsonrpc: "2.0"` field is present
- Verify `id` field matches between request and response

## Next Steps

### Explore A2A Further

1. **Try python-a2a library**: Build real HTTP-based A2A agents
2. **Read A2A specification**: a2a-protocol.org/latest/specification
3. **Deploy LangGraph with A2A**: Use LangGraph's native A2A support
4. **Experiment with Google ADK**: Try Google's A2A framework

### Build Real A2A Systems

**Project Ideas:**
1. **Agent Marketplace**: Platform where agents offer services
2. **Multi-Department AI**: HR, Finance, Legal agents collaborating
3. **Hybrid Local-Cloud**: Local agents + cloud specialist agents
4. **Research Network**: Specialized research agents from different providers

### Combine with Other Patterns

- **A2A + RAG**: Remote agents with knowledge bases
- **A2A + ReAct**: Remote agents with tool access
- **A2A + Supervisor**: Orchestrate both local and remote agents
- **A2A + Network**: Peer network including remote agents

## Congratulations!

You've completed the DevFest 2025 Local LLMs Workshop! ğŸ‰

You now understand:
- âœ… Local LLMs with Ollama
- âœ… RAG systems with vector stores
- âœ… LCEL for sequential chains
- âœ… ReAct agents with tool usage
- âœ… Supervisor multi-agent systems
- âœ… Network/Swarm agent collaboration
- âœ… **A2A protocol for cross-framework agent interoperability**

### The Complete Agent Architecture Stack

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     YOUR AI SYSTEM                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

APPLICATION LAYER (Your Use Case)
â”œâ”€â”€ Customer Support
â”œâ”€â”€ Research Assistant
â”œâ”€â”€ Content Generation
â””â”€â”€ Data Analysis

AGENT PATTERNS (Steps 3-6)
â”œâ”€â”€ Single Agent (ReAct) â† Step 3
â”œâ”€â”€ Supervisor Pattern â† Step 4
â”œâ”€â”€ Network Pattern â† Step 5
â””â”€â”€ A2A Protocol â† Step 6

KNOWLEDGE AUGMENTATION (Step 2)
â””â”€â”€ RAG with Vector Stores

FOUNDATION (Step 1)
â””â”€â”€ LLM (Ollama or Google)

PROTOCOLS & INTEGRATION
â”œâ”€â”€ MCP: Agent â†” Tools
â””â”€â”€ A2A: Agent â†” Agents
```

Happy building! ğŸš€
